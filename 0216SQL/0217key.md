# Enterprise Technical Design Specification

# Task Management System — Relational Database Architecture

---

---

## 2. System Goals

### 2.1 Functional Goals

The schema must support:

- User identity management
- Task creation and ownership
- Multi-user collaboration on tasks
- Workflow state tracking
- Preventing invalid or duplicate data

### 2.2 Non-Functional Goals

| Goal            | Description                       |
| --------------- | --------------------------------- |
| Data Integrity  | Prevent corruption automatically  |
| Scalability     | Handle large user/task growth     |
| Security        | Protect data from abuse & leakage |
| Performance     | Efficient querying under load     |
| Maintainability | Easy to evolve safely             |

---

## 3. Business Use Cases (Real Production Scenarios)

### Use Case 1 — Task Ownership

**Scenario:** A user creates multiple tasks.

**Expected Behavior:**

- Creator identity must always exist.
- Task must be deleted if owner is removed.

**Database Enforcement:**

```sql
creator_id REFERENCES users(id) ON DELETE CASCADE
```

### Use Case 2 — Team Collaboration

**Scenario:** Multiple users work on a single task.

**Solution:** Many-to-many junction table (`assignments`).

### Use Case 3 — Workflow Control

Allowed states:

```
backlog → in-progress → done → archived
```

Enforced via CHECK constraint.

### Use Case 4 — Data Recovery Safety

If a user is removed:

- All owned tasks removed automatically.
- Assignment links removed automatically.

---

## 4. Data Modeling Strategy

### 4.1 Entity Relationship Model

```
users (1) ------ (N) tasks
users (M) ------ (N) tasks via assignments
```

### 4.2 Why Three-Layer Architecture?

| Layer       | Responsibility          |
| ----------- | ----------------------- |
| Identity    | Who exists in system    |
| Resource    | What exists (tasks)     |
| Association | Who interacts with what |

---

## 5. Table Specifications (Expanded)

### 5.1 Identity Layer — users

**Purpose:** Stores authenticated entities responsible for ownership and access.

**Design Decisions**

- UUID instead of integer IDs
- Unique email and username
- Creation timestamp for auditing

### 5.2 Resource Layer — tasks

**Security-Oriented Design Choices**

1. Title validation

```sql
CHECK (char_length(trim(title)) > 0)
```

2. Status constraint

```sql
CHECK (status IN ('backlog','in-progress','done','archived'))
```

3. Ownership enforcement via foreign key.

### 5.3 Association Layer — assignments

Composite primary key:

```sql
PRIMARY KEY (task_id, user_id)
```

Benefits:

- Prevent duplicate assignments
- Atomic uniqueness
- No race-condition duplication

---

## 6. Security Architecture

### 6.1 Data Integrity as Security

Constraints prevent:

- Invalid states
- Duplicate relations
- Orphan records

### 6.2 Injection Resistance

- CHECK limits allowed values
- FK prevents fake references
- NOT NULL blocks malformed rows

### 6.3 Access Control Strategy (App Layer)

Users can modify tasks only if they:

- created the task, or
- are assigned to it.

### 6.4 Auditability

Use timestamps:

- `created_at`
- `assigned_at`

### 6.5 Cascading Deletes

Prevents sensitive leftover data when accounts are removed.

---

## 7. Failure Scenarios & Protection

- Invalid status insert → CHECK constraint error
- Concurrent duplicate assignment → Composite PK violation
- Parent deletion → Cascade maintains integrity

---

## 8. Performance Strategy

### 8.1 Index Recommendations

```sql
CREATE INDEX idx_assignments_user ON assignments(user_id);
CREATE INDEX idx_tasks_creator ON tasks(creator_id);
```

### 8.2 Query Optimization

Use joins; avoid duplicated data.

---

## 9. Scalability Considerations

Possible future extensions:

- Role-based access in assignments
- Soft deletes (`deleted_at`)
- Task event log table
- Multi-tenant `organization_id`

---

## 10. Operational Best Practices

- Use versioned migrations
- Daily backups + point-in-time recovery
- Monitor constraint violations and slow queries

---

## 11. Senior Engineering Insights

A junior engineer designs tables.  
A senior engineer designs **failure-proof systems**.

---
